
Conversation opened. 1 read message.

Skip to content
Using ATFS Lab., Limited Mail with screen readers
Search



Mail
COMPOSE
Labels
Inbox
Starred
Sent Mail
Drafts
Account
Forwarding_mail
MailChimp
Newsletter
ICO_Newsletter
Reporting
서비스등록
More 
Hangouts

 
 
  More 
1 of 376  
 
Print all In new window
Fwd: atfs smart contract 
Inbox
x 

David Kim
Attachments2:49 PM (1 hour ago)

to me 

David Kim  김도진
Chief Executive Officer  |  President & Founder

ATFS Lab., Limited
+82-10-4074-7403  |  david.kim@atfslab.io
248 Seocho-daero, Seocho-gu, Seoul 06647, Korea

Information in this e-mail is intended for the exclusive use of the individual or entity named above and may constitute information that is privileged or confidential or otherwise protected from disclosure. Dissemination, distribution, forwarding or copying of this e-mail by anyone other than the intended recipient is prohibited. If you have received this e-mail in error, please notify us immediately by telephone or e-mail (support@atfslab.io) and completely delete or destroy any and all electronic or other copies of the original message and any attachments. Thank you for your cooperation.

---------- Forwarded message ----------
From: Allen Sung <allen.sung@atfslab.io>
Date: 2017-11-21 14:42 GMT+09:00
Subject: atfs smart contract
To: David Kim <david.kim@atfslab.io>


아직 test 중이지만, git 코드란에 올리셔도 됩니다.
계속 commit하면서 update하면 되니까..

Attachments area
	
Click here to Reply or Forward
1.81 GB (6%) of 30 GB used
Manage
Program Policies
Powered by Google
Last account activity: 1 minute ago
Details


/**
 * This software is a subject to ATFSLab License Agreement.
 * No use or distribution is allowed without written permission from ATFSLab.
 * https://www.atfslab.io
 */

pragma solidity ^0.4.18;

/**
 * @title SafeMath
 * @dev Math operations with safety checks
 */
contract SafeMath 
{
  function safeMul( uint256 a, uint256 b ) internal constant returns (uint256) 
  {
    uint256 c = a * b;
    assert( a == 0 || c / a == b );
    return c;
  }

  function safeDiv( uint256 a, uint256 b ) internal constant returns (uint256) 
  {
    assert( b > 0 ); 
    uint256 c = a / b;
    assert( a == b * c + a % b );
    return c;
  }

  function safeSub( uint256 a, uint256 b ) internal constant returns (uint256) 
  {
    assert( a >= b );
    return a - b;
  }

  function safeAdd( uint256 a, uint256 b ) internal constant returns (uint256) 
  {
    uint256 c = a + b;
    assert( c >= a && c >= b );
    return c;
  }
}

/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 
{
  uint256 public mTotalSupply;

  function balanceOf( address who ) public constant returns (uint256);

  function allowance( address owner, address spender ) public constant returns (uint256);
  function approve( address spender, uint256 value ) public returns (bool);

  function transfer( address to, uint256 value ) public returns (bool);
  function transferFrom( address from, address to, uint256 value ) public returns (bool);
  
  event Transfer( address indexed from, address indexed to, uint256 value );
  event Approval( address indexed owner, address indexed spender, uint256 value );
}

/**
 * @title ERC20 token
 * @dev ERC20 token implementation
 */
contract ERC20Token is SafeMath, ERC20
{
  mapping( address => uint256 ) mBalances;
  mapping( address => mapping( address => uint256 ) ) mAllowed;
  
 /**
  * @dev returns the balance of the specified address.
  * @param owner address The address to get the the balance of.
  * @return uint256 the amount owned by the address.
  */
  function balanceOf( address owner ) public constant returns (uint256) 
  {
    return mBalances[ owner ];
  }
  
  /**
   * @dev Function to check the amount of tokens that an owner has allowed to a spender.
   * @param owner address The address which owns the tokens.
   * @param spender address The address which wants to spend the tokens.
   * @return uint256 the amount of tokens allowed to spend by the spender.
   */
  function allowance( address owner, address spender ) public constant returns (uint256) 
  {
    return mAllowed[ owner ][ spender ];
  }

  /**
   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * @param spender address The address which are allowed to spend message sender's token.
   * @param value uint256 The amount of tokens to be spent.
   */
  function approve( address spender, uint256 value ) public returns (bool) 
  {
    //
    // To change the approved amount you first have to reduce 
    //  the addresses'allowance to zero by calling - approve( spender, 0 )
    //  if it is not already 0 to mitigate the race condition described here:
    // 
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    //
    require( ( value == 0 ) || ( mAllowed[ msg.sender ][ spender ] == 0 ) );

    mAllowed[ msg.sender ][ spender ] = value;
    
    Approval( msg.sender, spender, value );
    
    return true;
  }
  
  /**
   * Fix for the ERC20 short address attack
   *
   * http://vessenes.com/the-erc20-short-address-attack-explained/
   */
  modifier checkPayloadSize( uint256 size ) 
  {
    if( msg.data.length < size + 4 ) {
      throw;
    }
    _;
  }
  
  /**
  * @dev transfer token to the address "to"
  * @param to address The address to transfer to.
  * @param value uint256 The amount to be transferred.
  */
  function transfer( address to, uint256 value ) public checkPayloadSize( 2*32 ) returns (bool) 
  {
    mBalances[ msg.sender ] = safeSub( mBalances[ msg.sender ], value );
    mBalances[ to ]         = safeAdd( mBalances[ to ], value );
    
    Transfer( msg.sender, to, value );
    return true;
  }

  /**
   * @dev Transfer tokens from one address to another
   * @param from address The address from which to send tokens
   * @param to address The address to transfer to.
   * @param value uint256 The amout of tokens to be transfered
   */
  function transferFrom( address from, address to, uint256 value ) public returns (bool) 
  {
    uint256 allowed = mAllowed[ from ][ msg.sender ];
     
    // will throw if allowed < value
    mAllowed[ from ][ msg.sender ] = safeSub( allowed, value );

    mBalances[ from ] = safeSub( mBalances[ from ], value );
    mBalances[ to ]   = safeAdd( mBalances[ to ], value );
    
    Transfer( from, to, value );
    return true;
  }
}

/**
 * @title Ownable
 * @dev Ownable provides basic authorization control or permission
 */
contract Ownable 
{
  address public mOwner;

  /**
   * @dev The Constructor sets `owner` of the contract with the sender
   */
  function Ownable( ) public 
  {
    mOwner = msg.sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner( ) 
  {
    require( msg.sender == mOwner );
    _;
  }

  /**
   * @dev set new owner of contract
   * @param newOwner The address of new owner
   */
  function setNewOwner( address newOwner ) public onlyOwner 
  {
    if( newOwner != address(0) ) 
    {
      mOwner = newOwner;
    }
  }
}

/**
 * @title Pausable
 * @dev implements an emergency "pause" of crowdsale.
 */
contract Pausable is Ownable 
{
  event Pause( );
  event Resume( );

  bool public mPaused = false;

  /**
   * @dev modifier to check "not paused" state
   */
  modifier notPaused( ) {
    require( !mPaused );
    _;
  }

  /**
   * @dev modifier to check "paused" state
   */
  modifier paused( ) {
    require( mPaused );
    _;
  }

  /**
   * @dev called to pause crowdsale
   */
  function pause( ) public onlyOwner notPaused returns (bool) {
    mPaused = true;
    Pause();
    return true;
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function resume( ) public onlyOwner paused returns (bool) {
    mPaused = false;
    resume( );
    return true;
  }
}

/**
 * @title ATFS Lab Token
 * @dev ERC20-compatible ATFS Lab Token - ATFS
 */
contract ATFSLabToken is ERC20Token, Pausable
{
  // token
  string  public constant mName 	 = 'ATFS Lab Token';
  string  public constant mSymbol 	 = 'ATFS';
  uint8   public constant mDecimals 	 = 6;
  
  // ICO constant
  uint256 public constant INITIAL_SUPPLY = 600 * ( 10 ** 6 ) * ( 10**uint256( mDecimals ) );
  uint256 public constant MIN_INVEST	 = ( 1*(10**18) )/10;	// 0.1 ether
  
  // uint256 public          ICO_START	 = 1515592800;		// Jan.10.2018 14:00:00
  uint256 public ICO_START = 1511049600;
  uint256 public constant ICO_PERIOD	 = 30;

  uint256[] public mTokenBonus;  
  
  // misc.
  uint64  public constant SEC_PER_DAY	 = 24*60*60;
  
  //
  // status  
  //
  
  // the amount of tokens sold during crowdsale
  uint256 public mTokenSold = 0; 	
  
  // multisig address to which all ethers will be sent
  address public mMultiSig;

  // event  
  event Burn( address burner, uint256 value );
  event Mint( address minter, uint256 value );
  
  /**
   * @dev ATFS Token Constructor
   */
  function ATFSLabToken( ) public 
  {
    mTotalSupply = INITIAL_SUPPLY;       
    mBalances[ msg.sender ] = INITIAL_SUPPLY;
    
    initTokenBonus( );
  }
  
  // fallback function when receiving Ether.
  function( ) public payable 
  {
    invest_internal( msg.sender, msg.value, true );
  }

  // wsung : owner or proxy
  // value in wei
  function invest( uint256 value ) public onlyOwner 
  {
    invest_internal( msg.sender, value, false );
  }
  
  // private function
  function invest_internal( address investor, uint256 value, bool real ) private notPaused
  {
    if( value < MIN_INVEST ) 
      throw;

    if( !crowdsaleOn( ) ) 
      throw;
        
    uint256 tokens = calcTokens( value );
    uint256 sold = safeAdd( mTokenSold, tokens );

    if( mTotalSupply < sold )
      throw;

    // in the context of investor
    transferFrom( mOwner, investor, tokens );
        
    mTokenSold = sold;
        
    // if real transfer of ether, send ether to multisig address
    if( real && ( mMultiSig != address( 0 ) ) )
    {
      // 
      // when send( ) fails, it will just return false, not throw exception
      // cf. address.transfer( )
      //
      if( !mMultiSig.send( value ) ) 
        throw; 
    }
        
    Transfer( this, investor, tokens );
  }
  
  // check unit conversion
  function calcTokens( uint256 value ) public returns ( uint256 )
  {
    uint32 idx = (uint32)( ( now - ICO_START ) / SEC_PER_DAY );
    uint256 ret = value * 2500 / ( 10**18 );
    
    return ( ret + ret * mTokenBonus[ idx ] / 100 );
  }

  // 
  // ERC20 interface
  //
  function transfer( address to, uint256 value ) public notPaused returns (bool)
  {
    return super.transfer( to, value );
  }

  function transferFrom( address from, address to, uint256 value ) public notPaused returns (bool)  
  {
    return super.transferFrom( from, to, value );
  }
  
  function approve( address spender, uint256 value) public notPaused returns (bool) 
  {
    return super.approve( spender, value );
  }
  
  //
  // change state variables
  //
  function burn( uint256 value ) public onlyOwner 
  {
    require( value > 0);

    address burner = msg.sender;
    
    mBalances[ burner ] = safeSub( mBalances[ burner ], value );
    mTotalSupply 	= safeSub( mTotalSupply, value );
    
    Burn( burner, value );
  }
  
  function mint( uint256 value ) public onlyOwner
  {
    require( value > 0 );
    
    address minter = msg.sender;
    
    mBalances[ minter ] = safeAdd( mBalances[ minter ], value );
    mTotalSupply      = safeAdd( mTotalSupply, value );
    
    Mint( minter, value );
  }
  
  function setMultiSig( address addr ) public onlyOwner
  {
    mMultiSig = addr;
  }
  
  function getMultiSig( ) public returns (address)
  {
    return mMultiSig;
  }
  
  //
  // private/internal
  //
  function crowdsaleOn( ) private returns (bool)
  {
    // 
    // now : uint, sec, current block timestamp, == block.timestamp
    //
    if( now >= ICO_START &&  ( ( now - ICO_START )/SEC_PER_DAY ) < ICO_PERIOD )
      return true;
    return false;
  }
  
  function initTokenBonus( ) private
  {
    mTokenBonus.push( 40 );
    mTokenBonus.push( 40 );    
    mTokenBonus.push( 40 );   	// 3-days
                      
    mTokenBonus.push( 30 );
    mTokenBonus.push( 30 );    
    mTokenBonus.push( 30 );    
    mTokenBonus.push( 30 );
    mTokenBonus.push( 30 );	// 5	  
                      
    mTokenBonus.push( 20 );    
    mTokenBonus.push( 20 );
    mTokenBonus.push( 20 );
    mTokenBonus.push( 20 );    
    mTokenBonus.push( 20 );    
    mTokenBonus.push( 20 );
    mTokenBonus.push( 20 );    	// 7
                      
    mTokenBonus.push( 10 );    
    mTokenBonus.push( 10 );
    mTokenBonus.push( 10 );    
    mTokenBonus.push( 10 );    
    mTokenBonus.push( 10 );
    mTokenBonus.push( 10 );    
    mTokenBonus.push( 10 );    	// 7
                      
    mTokenBonus.push( 5 );	
    mTokenBonus.push( 5 );    
    mTokenBonus.push( 5 );    
    mTokenBonus.push( 5 );
    mTokenBonus.push( 5 ); 	// 5
                      
    mTokenBonus.push( 0 );    
    mTokenBonus.push( 0 );
    mTokenBonus.push( 0 );    
  }
}  


  
  
  
  
  
sc_atfs.sol
Open with Google Docs
Displaying sc_atfs.sol.
